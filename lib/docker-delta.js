// Generated by CoffeeScript 1.10.0
(function() {
  var DELTA_OUT_OF_SYNC_CODES, Docker, OutOfSyncError, Promise, TypedError, btrfs, bufIndexOfByte, docker, parseDeltaStream, path, rsync, spawn, stream, utils,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  spawn = require('child_process').spawn;

  Promise = require('bluebird');

  stream = require('readable-stream');

  TypedError = require('typed-error');

  rsync = require('./rsync');

  btrfs = require('./btrfs');

  utils = require('./utils');

  Docker = require('docker-toolbelt');

  docker = new Docker();

  DELTA_OUT_OF_SYNC_CODES = [23, 24];

  exports.OutOfSyncError = OutOfSyncError = (function(superClass) {
    extend(OutOfSyncError, superClass);

    function OutOfSyncError() {
      return OutOfSyncError.__super__.constructor.apply(this, arguments);
    }

    return OutOfSyncError;

  })(TypedError);

  exports.createDelta = function(srcImage, destImage, v2) {
    var config, deltaStream, rsyncStream;
    if (v2 == null) {
      v2 = true;
    }
    deltaStream = new stream.PassThrough();
    rsyncStream = Promise.resolve([srcImage, destImage]).bind(docker).map(docker.imageRootDir).map(function(rootDir) {
      return path.join(rootDir, '/');
    }).spread(rsync.createRsyncStream);
    config = docker.getImage(destImage).inspectAsync().get('Config');
    Promise.all([config, rsyncStream]).spread(function(config, rsyncStream) {
      var metadata;
      if (v2) {
        metadata = {
          version: 2,
          dockerConfig: config
        };
        deltaStream.write(JSON.stringify(metadata));
        deltaStream.write(new Buffer([0x00]));
      }
      return rsyncStream.pipe(deltaStream);
    })["catch"](function(e) {
      return deltaStream.emit('error', e);
    });
    return deltaStream;
  };

  bufIndexOfByte = function(buf, byte) {
    var b, i, j, len;
    for (i = j = 0, len = buf.length; j < len; i = ++j) {
      b = buf[i];
      if (b === byte) {
        return i;
      }
    }
    return -1;
  };

  parseDeltaStream = function(input) {
    return new Promise(function(resolve, reject) {
      var buf, parser;
      buf = new Buffer(0);
      parser = function() {
        var chunk, chunks, e, error, metadata, sep;
        chunks = [buf];
        while (chunk = input.read()) {
          chunks.push(chunk);
        }
        buf = Buffer.concat(chunks);
        sep = bufIndexOfByte(buf, 0x00);
        if (sep !== -1) {
          input.removeListener('readable', parser);
          input.unshift(buf.slice(sep + 1));
          try {
            metadata = JSON.parse(buf.slice(0, sep));
          } catch (error) {
            e = error;
            return reject(e);
          }
          if (metadata.version === 2) {
            return resolve(metadata);
          } else {
            return reject(new Error('Uknown version: ' + metadata.version));
          }
        }
      };
      return input.on('readable', parser);
    });
  };

  exports.applyDelta = function(srcImage) {
    var deltaStream, dstId, srcRoot;
    deltaStream = new stream.PassThrough();
    if (srcImage != null) {
      srcRoot = docker.imageRootDir(srcImage).then(function(srcRoot) {
        return srcRoot = path.join(srcRoot, '/');
      });
    } else {
      srcRoot = null;
    }
    dstId = parseDeltaStream(deltaStream).get('dockerConfig').bind(docker).then(docker.createEmptyImage);
    Promise.all([docker.infoAsync().get('Driver'), srcRoot, dstId, dstId.then(docker.imageRootDir)]).spread(function(dockerDriver, srcRoot, dstId, dstRoot) {
      var rsyncArgs;
      dstRoot = path.join(dstRoot, '/');
      rsyncArgs = ['--timeout', '300', '--archive', '--delete', '--read-batch', '-', dstRoot];
      return Promise.attempt(function() {
        switch (dockerDriver) {
          case 'btrfs':
            if (srcRoot != null) {
              return btrfs.deleteSubvolAsync(dstRoot).then(function() {
                return btrfs.snapshotSubvolAsync(srcRoot, dstRoot);
              });
            }
            break;
          case 'overlay':
            if (srcRoot != null) {
              return rsyncArgs.push('--link-dest', srcRoot);
            }
            break;
          default:
            throw new Error("Unsupported driver " + dockerDriver);
        }
      }).then(function() {
        rsync = spawn('rsync', rsyncArgs);
        deltaStream.pipe(rsync.stdin);
        return utils.waitPidAsync(rsync);
      }).then(function() {
        return utils.waitPidAsync(spawn('sync'));
      }).then(function() {
        return deltaStream.emit('id', dstId);
      });
    })["catch"](function(e) {
      return dstId.then(function(dstId) {
        return docker.getImage(dstId).removeAsync()["catch"](function(e) {
          return deltaStream.emit('error', e);
        });
      }).then(function() {
        var ref;
        if (ref = e != null ? e.code : void 0, indexOf.call(DELTA_OUT_OF_SYNC_CODES, ref) >= 0) {
          return deltaStream.emit('error', new OutOfSyncError('Incompatible image'));
        } else {
          return deltaStream.emit('error', e);
        }
      });
    });
    return deltaStream;
  };

}).call(this);
